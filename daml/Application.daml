module Application where

import DA.Time
import Daml.Script
import Utility (makePartiesFrom)

data Status = New | InProgress | Concluded deriving (Eq, Show)

template Application
  with
    employee, courseParty: Party
    name, address, email: Text
    phone: Optional Text
    timestamp: Time
    status: Status
    score: Optional Int
    comment: Optional Text
  where
    signatory employee
    observer courseParty
    
    choice SubmitApplicationAndSetStatus : ContractId Application
      controller employee
      do
        create this with status = newStatus


template Account
  with
    employee, course: Party
    points: Int
    timestamp: Time
  where
    signatory course
    observer employee

    choice AddPoints : ContractId Account
      controller course
      do
        create this with points = points + newPoints


template CourseService
  with
    employee: Party
    course: Party
  where
    signatory course
    observer employee

    nonconsuming choice CreateBlankApplication : ContractId Application
      controller employee
      do
        now <- getTime
        create Application with
          employee
          courseParty = course
          name = ""
          address = ""
          email = ""
          phone = None
          timestamp = now
          status = New
          score = None
          comment = None

    choice CompleteCourse : ContractId Application
        controller course 
            do
            exercise appId SubmitApplicationAndSetStatus with newStatus = "Concluded"
            account <- fetch (employee, course)
            exercise account AddPoints 100
            pure appId

  
{-
setup : Script ()
setup = do
  [damlcoding, marcel] <- makePartiesFrom ["damlcoding", "Marcel"]
  time <- getTime
  _ <- submit damlcoding do
    create (CourseService employee = marcel course = damlcoding)
  _ <- submit damlcoding do
    create (Application employee marcel "" "" "" None time New None)
  pure ()

test : Script ()
test = do
  [damlcoding, marcel] <- makePartiesFrom ["damlcoding", "Marcel"]
  now <- getTime
  _ <- submit damlcoding do
    create (CourseService employee = marcel course = damlcoding)
  appId <- submit damlcoding do
    create (Application employee marcel "" "" "" None now New None)
  submit damlcoding do
    exercise @CourseService (CourseService employee = marcel course = damlcoding) (CompleteCourse appId)
  let expectedPoints = 50 * 10
  account <- query @Account (marcel, appId)
  case account of
    Nothing -> error "Não foi possível encontrar a conta associada à aplicação."
    Just acc -> assertMsg ("Pontos não foram adicionados corretamente à conta após completar o curso. Expected: " ++ show expectedPoints ++ ", Actual: " ++ show acc) (acc == expectedPoints)
-}